#!/bin/bash
#
#
#

PATH="$PATH:."

. argsparse.sh

shopt -s extdebug
errors=0

err_trap() {
	: $((errors+=1))
	return 1
}

trap err_trap ERR

print_exit_status() {
    # Prints [OK] at the end of the screen of first argument is 0,
    # else [FAILURE].
    # 1st Parameter: a number, usually the exit status of your
    # previous command. If omitted, will use $?.
    # returns the first parameter value
    local ret="${1:-$?}"
    # If you want you can override the FAILED and OK messages by
    # pre-defining those variables.
    local FAILED=${FAILED:-FAILED}
    local OK=${OK:-OK}
    # Move to column default is 70
    local COL=${COL:=70}
    [[ -t 1 ]] && echo -en "\033[${COL}G"
    # Colors
    if [[ -t 1 ]]
    then
        local COLOR_SUCCESS=${COLOR_SUCCESS:-'\033[1;32m'}
        local COLOR_FAILURE=${COLOR_FAILURE:-'\033[1;31m'}
        local COLOR_WARNING='\033[1;33m' COLOR_NORMAL='\033[0;39m'
    else
        local COLOR_SUCCESS= COLOR_FAILURE= COLOR_WARNING= COLOR_NORMAL=
    fi
    [[ "$ret" -eq 0 ]] && echo -e "[$COLOR_SUCCESS$OK$COLOR_NORMAL]" || \
		echo -e "[$COLOR_FAILURE$FAILED$COLOR_NORMAL]"
    return $ret
}

echo_for_print_status() {
    local m="$1"
    if tty >/dev/null 2>&1 && [[ -n "$PRINT_STATUS_COLOR" ]]
    then
        m="$(tput setaf $PRINT_STATUS_COLOR)$m$(tput sgr0)"
    fi
    printf "%s: " "$m"
}

exec_and_print_status() {
    # prints a message, execute a command and print its exit status
    # using print_exit_status function.
    # 1st Parameter: a message
    # all other parameter: the command to execute
    # returns the exit status code of the command
    [[ $# -lt 2 ]] && return 1
    local m="$1" ; shift
    PRINT_STATUS_COLOR="$PRINT_STATUS_COLOR" echo_for_print_status "$m"
    "$@"
    print_exit_status $?
}

(
	argsparse_usage_description="Usage has been triggered"
	echo_for_print_status "Checking no parameter triggers usage"
	( 
		argsparse_parse_options
	) | grep -q "$argsparse_usage_description"
	[ ${PIPESTATUS[0]} -ne 0 -a ${PIPESTATUS[1]} -eq 0 ]
	print_exit_status 
)

(
	argsparse_usage_description="Usage has been triggered"
	echo_for_print_status "Checking dummy option triggers usage"
	( 
		argsparse_parse_options --dumb 2>/dev/null
	) | grep -q "$argsparse_usage_description"
	[ ${PIPESTATUS[0]} -ne 0 -a ${PIPESTATUS[1]} -eq 0 ]
	print_exit_status 
)

(
	argsparse_use_option first-option "first option description"
	echo_for_print_status "Checking if option description appear in usage"
	(
		argsparse_parse_options -h
	) | grep -q "first option description"
	print_exit_status
)

default_test() {
	[[ $? -eq 0 ]]
}

failure() {
	[[ $? -ne 0 ]]
}

parse_option_wrapper() {
	local message=$1
	local TEST=${TEST:-default_test}
	shift
	echo_for_print_status "Checking $message"
	(
		argsparse_parse_options "$@"
		$INNERTEST
	) >/dev/null 2>&1
	$TEST
	print_exit_status || exit
}

(
	argsparse_use_option shortcut ""
	parse_option_wrapper "option detection" --shortcut

	argsparse_set_option_property short:S shortcut
	parse_option_wrapper "short property" -S
)

(
	argsparse_use_option =shortcut ""
	parse_option_wrapper "= in optstring" -s
)

value_check_test() {
	[[ ${program_options[$value_check_option]} = $value_check_value ]]
}

value_check() {
	local value_check_option=$1
	local value_check_value=$2
	shift 2
	INNERTEST=value_check_test parse_option_wrapper "$@"
}

(
	argsparse_use_option value ""
	argsparse_set_option_property value value
	TEST=failure parse_option_wrapper "if value property expects value" --value
	value_check value 1 "if value is correctly detected" --value 1
)

(
	argsparse_use_option value: ""
	value_check value 1 "if value is correctly detected with optstring" --value 1
	TEST=failure parse_option_wrapper "if value property expects value if set with optstring" --value
)	

(
	argsparse_use_option option1 ""
	argsparse_use_option option2 "" mandatory
	TEST=failure parse_option_wrapper "if missing mandatory option triggers error" --option1
	parse_option_wrapper "if mandatory option makes return code 0" --option1 --option2
	argsparse_use_option option3 "" mandatory
	TEST=failure parse_option_wrapper "if missing mandatory options trigger error (1)" --option1
	TEST=failure parse_option_wrapper "if missing mandatory options trigger error (2)" --option1 --option2
	TEST=failure parse_option_wrapper "if missing mandatory options trigger error (3)" --option1 --option3
	parse_option_wrapper "if missing mandatory options trigger error (4)" --option3 --option2
)

(
	argsparse_use_option option1 ""
	argsparse_use_option option2 "" alias:option1
	value_check option1 1 "simple alias" --option1
	argsparse_use_option option3 "" alias:option2
	value_check option1 1 "recursive alias" --option1
)

(
	argsparse_use_option option1 ""
	argsparse_use_option option2 "" require:option1
	parse_option_wrapper "simple require (1)" --option2 --option1
	TEST=failure parse_option_wrapper "simple require (2)" --option2
	argsparse_use_option option3 "" require:option2
	TEST=failure parse_option_wrapper "recursive require (1)" --option3
	TEST=failure parse_option_wrapper "recursive require (2)" --option3 --option2
	parse_option_wrapper "recursive require (3)" --option3 --option2 --option1
)

(
	argsparse_use_option option1 ""
	argsparse_use_option option2 ""
	argsparse_use_option option3 "" require:"option1 option2"
	TEST=failure parse_option_wrapper "multiple require (1)" --option3
	TEST=failure parse_option_wrapper "multiple require (2)" --option3 --option2
	TEST=failure parse_option_wrapper "multiple require (3)" --option3 --option1
	parse_option_wrapper "multiple require (4)" --option3 --option2 --option1
)

dir=$(mktemp -d)
fifo="$dir/fifo"
file=$(mktemp --tmpdir="$dir")
mkfifo "$fifo"
declare -A types=(
	[link]="$dir/link1 $dir/link2"
	[file]="$file ${types[link]}"
	[directory]=". .. $dir $dir/linkdir"
	[pipe]="$fifo"
	[terminal]=0
	[socket]=/dev/log
	[link]="$dir/link1 $dir/link2"
	[char]="c . 0 @"
	[unsignedint]=123
	[int]="1 123 0 -1 -938945349"
	[hexa]="0x123abc 71234 abc"
	[ipv4]="192.168.40.254 127.0.0.1 1.2.3.4"
	[ipv6]="2001:7a8:b018::1 ::1 2001:7a8:b018:0:21f:c6ff:fe59:71fd"
	[host]="livna.org ${types[ipv4]} ${types[ipv6]}"
	[username]=$(whoami)
	[group]=$(id -gn)
	[port]="ssh 80"
	[portnumber]=1234
	[hostname]="livna.org localhost"
)
(cd "$dir" && ln -s "$file" link1 && ln -s asdf link2 && ln -s . linkdir)
for type in "${!types[@]}"
do
	(
		argsparse_use_option option: "" "type:$type"
		# Left unquoted on purpose. There's no funny chars in this array.
		i=1
		for value in ${types[$type]}
		do
			parse_option_wrapper "type '$type' ($i)" --option "$value"
			: $((i++))
		done
	)
done

declare -A bad_types=(
	[file]=". .. $dir $fifo"
	[directory]="${types[file]} $fifo $dir/link1"
	[pipe]="${types[file]} ${types[dir]}"
	[socket]="${types[file]} $fifo $dir/link1"
	[link]="${types[file]} $fifo"
	[char]="12 abc"
	[unsignedint]="-1 -2234958 abc"
	[int]="a b casdf"
	[ipv4]="${types[ipv6]}"
	[ipv6]="${types[ipv4]}"
	[host]="livna.org1"
	[username]="asdkfjasdkfanfk1234"
	[group]="asdkfjasdkfanfk1234"
	[port]="12345678 foobar"
	[portnumber]=12345678
	[hostname]="livna.org1 google.com1"
)

for type in "${!bad_types[@]}"
do
	(
		argsparse_use_option option: "" "type:$type"
		# Left unquoted on purpose. (again)
		i=1
		for value in ${bad_types[$type]}
		do
			TEST=failure parse_option_wrapper "failure with type '$type' ($i)" --option "$value"
			: $((i++))
		done
	)
done

(
	argsparse_use_option option: "" "type:terminal"
	TEST=failure parse_option_wrapper "failure with type 'terminal' (1)" --option 0 </dev/null
)

rm -Rf "$dir"

if [[ $errors -ne 0 ]]
then
	printf "%d error(s) encountered. (See above)\n" "$errors"
	exit 1
else
	exit 0
fi
